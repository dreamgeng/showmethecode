# showmethecode
* 项目地址：https://github.com/Show-Me-the-Code/show-me-the-code
* 此仓库只作为自己平时刷题记录
* 会记录一些算法思想和题解方法

## 极客时间－数据结构与算法之美

### 数组（极客05）

数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。

#### **数组如何实现随机访问**

1.  数组是一种**线性表**数据结构，用**连续的存储空间存储相同类型数据**

   - 线性表：数组、链表、队列、栈 
   - 非线性表：树 图
   - 连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工

2. 数组如何实现下标随机访问

   * 引入数组在内存中的分配图，得出寻址公式

   * 一维数组：`a[k]_address = base_address + k * type_size`

   * 二维数组：对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：

     `address = base_address + ( i * n + j) * type_size`

   *  纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。
       正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）

3. 低效的插入和删除

   * 插入：插入最后最好O(1)，插入开头 最坏O(n) ，平均O(n)
   * 但是数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。
   * 删除：从最后删除最好O(1) ，从头删除最坏O(n) ，平均O(n)
   * 多次删除集中在一起，提高删除效率
     记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。

4. 警惕数组的访问越界问题
   用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。

5. 容器能否完全替代数组
   相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。但一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
   数组适合的场景：
   1）    Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组
   2）    若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
   3）    表示多维数组时，数组往往更加直观。
   4）    业务开发容器即可；底层开发，如网络框架，性能优化，选择数组。

6. 解答开篇问题
   1）    从偏移角度理解a[0] ，0实际为偏移量，如果从1计数，a[k]的内存地址变为`a[k]_address = base_address + (k-1)*type_size`，会多出K-1。增加cpu负担。
   2）    也有一定的历史原因

### 如何优雅的写出链表代码？6大学习技巧(极客07)

#### 理解指针或引用的含义
1.含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。
2.示例：

```
p—>next = q; 表示p节点的后继指针存储了q节点的内存地址。
p—>next = p—>next—>next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。
```

#### 警惕指针丢失和内存泄漏（单链表）
1.插入节点
在节点a和节点b之间插入节点x，b是a的下一节点，p指针指向节点a，则造成指针丢失和内存泄漏的代码：`p—>next = x;x—>next = p—>next; `显然这会导致x节点的后继指针指向自身。
正确的写法是2句代码交换顺序，即：`x—>next = p—>next; p—>next = x;`
2.删除节点
在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：`p—>next = p—>next—>next;`

#### 利用“哨兵”简化实现难度
1.什么是“哨兵”？
链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。
2.未引入“哨兵”的情况
如果在p节点后插入一个节点，只需2行代码即可搞定：

```
new_node—>next = p—>next;
p—>next = new_node;
```

但，若向空链表中插入一个节点，则代码如下：

```
if(head == null){
head = new_node;
}
```

如果要删除节点p的后继节点，只需1行代码即可搞定：
`p—>next = p—>next—>next;`
但，若是删除链表的最后一个节点（链表中只剩下这个节点），则代码如下：

```
if(head—>next == null){
head = null;
}
```

从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。
#### 引入“哨兵”的情况
“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。
#### “哨兵”还有哪些应用场景？
这个知识有限，暂时想不出来呀！但总结起来，哨兵最大的作用就是简化边界条件的处理。

#### 重点留意边界条件处理
经常用来检查链表是否正确的边界4个边界条件：
1.如果链表为空时，代码是否能正常工作？
2.如果链表只包含一个节点时，代码是否能正常工作？
3.如果链表只包含两个节点时，代码是否能正常工作？
4.代码逻辑在处理头尾节点时是否能正常工作？

#### 举例画图，辅助思考
核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。

#### 多写多练，没有捷径
#### 5个常见的链表操作：(见王争老师github)
1.单链表反转
2.链表中环的检测
3.两个有序链表合并
4.删除链表倒数第n个节点
5.求链表的中间节点

### 栈：如何实现浏览器的前进和后退功能？(极客08)

#### 如何理解“栈”？

后进者先出，先进者后出，这就是典型的“栈”结构。从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。

那么相比数组和列表，栈只带给我们限制，而并没有任何优势，为什么还要使用呢？

事实上，从功能上来说，数组或链表确实可以替代栈，但特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多操作接口，操作上灵活，但使用时不可控，自然就容易出错。

所以，当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出和先进后出的特性时，就应该选择栈这种数据结构。

#### 如何实现一个栈？

有两种方式可以实现：用数组实现的顺序栈，和用链表实现的链式栈。

#### 时间与空间复杂度

不管是顺序栈和链式栈，我们存储数据都只需要一个大小为ｎ的数组就够了，在入栈和出栈操作时只需要一两个临时变量存储空间，所以空间复杂度为O(1)

**注意**：对于空间复杂度的分析，是指除了原本的数据存储空间外，算法运行还需要的额外的存储空间，而不是说存储数据需要一个大小为ｎ的数组，空间复杂度就为O(n)

时间复杂度：不管是顺序栈还是链式栈，入栈和出栈都只涉及栈顶和个别数据的操作，所以时间复杂度为O(1)

#### 支持动态扩容的顺序栈

其实实现方法和数组动态扩容类似：即只需要底层依赖支持一个支持动态扩容的数组即可，当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组。

那么支持动态扩容的顺序栈，如何分析时间复杂度呢？

对于出栈操作来说，不涉及内存重新申请和数据搬移，所以时间复杂度仍为O(1)

但是对于入栈操作来说，当占中有剩余空间时，时间复杂度仍为O(1)；但是当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就成为O(n)

#### 栈在函数调用中的应用

操作系统为每个线程分配一块独立的内存空间，这块空间被组织成为栈这种结构，用来存储函数调用时的临时变量，每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用的函数完成返回之后，将这个函数对应的栈帧出栈

#### 栈在表达式求值中的应用

对于只包含加减乘除的四则运算，如何实现表达式求值呢？

实际上，编译器是通过两个栈来实现的。其中一个保存操作数的栈，另一个保存运算符的栈。从左向右遍历表达式，当遇到数字，直接压入操作数栈，当遇到运算符，就与运算符栈的栈顶元素进行比较。

如果比运算符栈顶元素优先级高，就将当前运算符压入栈；如果低，就从运算符栈顶取出运算符，并从操作数栈顶取出两个操作数，然后进行计算，再把计算完的结果压入操作数，继续比较。

#### 栈在括号匹配中的应用

#### 解答开篇：如何实现浏览器的前进和后退功能？

我们使用两个栈，Ｘ和Ｙ，把首次浏览的页面依次压入栈Ｘ，当点击后退按钮时，再依次从栈Ｘ中出栈，并将出栈的数据依次放入Ｙ。当点击前进按钮时，依次从Ｙ中取出数据，放入Ｘ中，当X中没有数据时，就说明没有页面可以继续后退浏览了，当栈Ｙ中没有数据，就说明没有页面可以点击前进浏览了。

### 队列：队列在线程池等有限资源池中的应用

#### 什么是队列？

1. 先进者先出，这就是典型的“队列”结构。
2. 支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。
3. 所以，和栈一样，队列也是一种操作受限的线性表

#### 如何实现对列？

**队列API**

```
public interface Queue<T> {
public void enqueue(T item); //入队
public T dequeue(); //出队
public int size(); //统计元素数量
public boolean isNull(); //是否为空
}
```

**数组实现（顺序队列）**：对于栈来说，只需要一个栈顶指针就可以了，但是队列需要两个指针：一个head指针，指向队头，一个tail指针，指向队尾。

但是和数组一样，当tail移动到队尾，即数组中没有空闲空间时，就无法继续添加数据了，那么该如何解决呢？

和数组一样，每次出队相当于删除数组中下标为０的数据，要搬移整个队列的数据，这样出队的时间复杂度就会从Ｏ(1)变为Ｏ(n)，如何优化呢？

实际上，在出队时不需要搬移数据，如果没有空闲空间了，只需要在入队是集中进行一次搬移操作。

**链表实现（链式队列)**

基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。

```
入队时，tail->next= new_node, tail=tail->next
出队时，head=head->next
```

**循环队列（基于数组）**

循环队列可以成功避免数据搬移的操作，实现循环队列的关键是：确定好队空的队满的判定条件。

在实现非循环的队列时，队满`tail=n`，队空`head=tail`

实现循环队列时，队空仍为`head=tail`，队满为`(tail+1)%n=head`

#### 队列有哪些常见的应用？
**阻塞队列**
在队列的基础上增加阻塞操作，就成了阻塞队列。

阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。

从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。
**并发队列**

在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。

并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。

实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

#### 线程池资源枯竭时的处理
在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。
#### 思考
除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？

今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？

### 递归：如何用三行代码找到“最终推荐人”？（极客10）

现在很多ａｐｐ都有推荐注册返佣金的功能，在这个功能中，用户Ａ推荐Ｂ来注册，用户Ｂ推荐C来注册，我们可以说，用户C的最终推荐人为Ａ，用户Ｂ也是A，而A没有最终推荐人。

基于这个背景：给定一个用户ID，如何查找这个用户的最终推荐人？

#### 如何理解递归？

递归：可以理解为去的过程叫递，回来的过程叫归（结合极客10给出的例子）

基本上，所有的递归问题都可以用递推公式来解决。

#### 递归需要满足的三个条件

* 一个问题的解可以分为几个子问题的解
* 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
* 存在递归终止条件

#### 如何编写递归代码？

最关键的就是：写出递推公式，找到终止条件，剩下的就是将递推公式转化为代码。

所以，写递归代码的关键是找到如何将大问题分解为小问题的规律，并且基于此写出递归公式，然后再推敲终止条件，最终将递推公式和终止条件翻译成代码。

这里有一个**思维上的误区**：对于递归代码，我们总想试图想清楚递和归过程的做法，实际上就是陷入了思维误区，很多时候我们理解吃力，是因为我们自己给自己制造了这种理解障碍

所以，遇到递归，我们就把他抽象成为一个递推公式，不要想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

#### 递归代码要警惕堆栈溢出

#### 递归代码要警惕重复计算

#### 如何将递归代码改写为非递归代码？

**最后，递归代码虽然简洁高效，但是递归代码也有很多弊端，比如：堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码时，一定要控制好这些副作用！**

